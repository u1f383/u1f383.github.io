---
layout: post
title:  "CTF-style Tricks of Linux Kernel Exploitation - Part 2"
categories: linux
---

- Part1: [CTF-style Tricks of Linux Kernel Exploitation - Part 1]({% post_url 2024-08-04-ctf-style-tricks-of-linux-kernel-exploitation-part-1 %})
- Part2: [CTF-style Tricks of Linux Kernel Exploitation - Part 2]({% post_url 2024-08-07-ctf-style-tricks-of-linux-kernel-exploitation-part-2 %})

é€™ç¯‡æ–‡ç« æœƒç¹¼çºŒåˆ†æ CTF ä¸­æœ‰å“ªäº›æœ‰è¶£çš„ Linux kernel exploit æŠ€å·§ï¼


## 3. Control RIP

### 3.1 SECCON CTF 2021 - kone_gadget
> åƒè€ƒï¼š https://ptr-yudai.hatenablog.com/entry/2021/12/19/232158#Pwnable-365pts-kone_gadget

è©²é¡Œç›®åœ¨å•Ÿç”¨ smapã€smep èˆ‡é—œé–‰ KASLR çš„å½¢æ³ä¸‹ï¼Œæä¾› user space syscall æ§ RIP çš„ primitiveï¼Œä½†æ˜¯åœ¨ jmp å‰æ‰€æœ‰ register éƒ½æœƒè¢«æ¸…ç©ºã€‚

``` c
SYSCALL_DEFINE1(seccon, unsigned long, rip)
{
    asm volatile("xor %%edx, %%edx;"
               "xor %%ebx, %%ebx;"
               "xor %%ecx, %%ecx;"
               "xor %%edi, %%edi;"
               "xor %%esi, %%esi;"
               "xor %%r8d, %%r8d;"
               "xor %%r9d, %%r9d;"
               "xor %%r10d, %%r10d;"
               "xor %%r11d, %%r11d;"
               "xor %%r12d, %%r12d;"
               "xor %%r13d, %%r13d;"
               "xor %%r14d, %%r14d;"
               "xor %%r15d, %%r15d;"
               "xor %%ebp, %%ebp;"
               "xor %%esp, %%esp;"
               "jmp %0;"
               "ud2;"
               : : "rax"(rip));
    return 0;
}
```

Linux kernel ç‚ºäº†å¢åŠ åŸ·è¡Œé€Ÿåº¦ï¼Œæœƒç”¨ Just-In-Time (JIT) çš„æ–¹å¼æŠŠ BPF bytecode è½‰æ›æˆ native assembly code ä¾†åŸ·è¡Œã€‚é™¤äº†ç›´æ¥å‘¼å« bpf syscall å»ºç«‹ä¸€å€‹ BPF program å¤–ï¼Œkernel ä¸­è¨±å¤š feature åº•å±¤å…¶å¯¦éƒ½æœ‰ç”¨åˆ° BPFï¼Œåƒæ˜¯ç”¨ä¾†æª¢æŸ¥ syscall åˆæ³•æ€§çš„ **seccomp rule**ï¼Œ

```c
// kernel/seccomp.c
static struct seccomp_filter *seccomp_prepare_filter(/* ... */)
{
    // [...]
    ret = bpf_prog_create_from_user(&sfilter->prog, fprog,
                    seccomp_check_filter, save_orig);
    // [...]
}

int bpf_prog_create_from_user(/* ... */)
{
    // [...]
    fp = bpf_prepare_filter(fp, trans);
    // [...]
}
```

æˆ–è€…ç”¨ä¾†è™•ç† packet çš„ **socket filter**ã€‚

```c
// net/core/filter.c
int sk_attach_filter(/* ... */)
{
    struct bpf_prog *prog = __get_filter(fprog, sk);
    // [...]
}

static struct bpf_prog *__get_filter(/* ... */)
{
    // [...]
    return bpf_prepare_filter(prog, NULL);
}
```

ç„¶è€Œï¼Œé€™å…©å€‹æ©Ÿåˆ¶ä¸¦ä¸æ˜¯ç›´æ¥ä½¿ç”¨ BPF programï¼Œè€Œæ˜¯ç”¨åŠŸèƒ½ç›¸è¼ƒä¾·é™çš„ **filter program**ã€‚Filter program èƒ½ä½¿ç”¨çš„ bytecode æ¯”è¼ƒå°‘ï¼Œéƒ½æ˜¯æ¯”è¼ƒåŸºæœ¬çš„æ“ä½œï¼Œå¦‚ load const æˆ–æ˜¯ç°¡å–®çš„åŠ æ¸›æ³•é‹ç®—ã€‚ç•¶ process è«‹æ±‚ attach filter program åˆ° process æˆ–æ˜¯ socket æ™‚ï¼Œkernel æœƒå‘¼å« `bpf_prepare_filter()` ä¾†è™•ç†ã€‚è©² function æœƒå…ˆæª¢æŸ¥ filter program çš„åˆæ³•æ€§ï¼Œåƒæ˜¯çœ‹æ˜¯å¦æœ‰ä¸åœ¨ç™½åå–®å…§çš„ operationï¼Œæˆ–æ˜¯å¦æœ‰é™¤ 0 çš„æ“ä½œ [1] ç­‰ç­‰ã€‚ç•¶æª¢æŸ¥å®Œå¾Œï¼Œ`bpf_migrate_filter()` [2] æœƒå°‡ filter program çš„ instructions **è½‰æ›æˆ BPF bytecode çš„æ ¼å¼**ä¸¦åš JITã€‚

```c
static struct bpf_prog *bpf_prepare_filter(/* ... */)
{
    // [...]
    err = bpf_check_classic(fp->insns, fp->len); // [1]
    
    // [...]
    fp = bpf_migrate_filter(fp); // [2]
    
    // [...]
}
```

å¦‚æœæœ‰ç¨å¾®ç©é v8 exploit æ‡‰è©²å° JIT ä¸é™Œç”Ÿï¼Œæœ‰ä¸€æ‹›åˆ©ç”¨æ–¹å¼å°±æ˜¯é€é const value åœ¨ JIT code ä¸­æ§‹é€  shellcodeï¼Œä¸¦ä½¿ç”¨ related jmp instruction æŠŠæ¯å€‹ shellcode ç‰‡æ®µä¸²èµ·ä¾†ï¼Œè‹¥è¦å¢åŠ ç©©å®šåº¦é‚„å¯ä»¥å…ˆ spray NOPsã€‚ä¹‹å¾Œåªè¦æƒ³è¾¦æ³• overwrite JIT function çš„ entry åˆ° JIT code çš„ä¸­é–“ï¼Œå°±å¯ä»¥åœ¨å‘¼å« JS Function æ™‚åŸ·è¡Œåˆ°ç”± const æ‰€æ§‹é€ çš„ shellcodeï¼Œç´°ç¯€å¯ä»¥åƒè€ƒ mem2019 çš„ [Dice CTF Memory Hole: Breaking V8 Heap Sandbox](https://mem2019.github.io/jekyll/update/2022/02/06/DiceCTF-Memory-Hole.html)ã€‚

Linux kernel çš„ BPF JIT code ä¹Ÿå¯ä»¥é€éé¡ä¼¼çš„æ–¹å¼ä¾†æ§‹é€  shellcodeï¼ŒåŒæ™‚é€™ä¹Ÿæ˜¯ä½œè€…çš„é æœŸè§£æ³•ã€‚Filter program ä¸­ load const value æ˜¯é€é bytecode `BPF_LD + BPF_K` ä¾†å®Œæˆï¼Œè€Œ JIT å®Œå¾Œçš„ x64 native instruction å‰‡æ˜¯ 5 bytes çš„ `mov eax, XXXXX`ã€‚å¦‚æœå°‡ 4 bytes çš„ const value æ§æˆ 2 bytes çš„ shellcode åŠ ä¸Š 2 bytes çš„ `jmp` instructionï¼Œå‰‡æ¯å€‹ shellcode ç‰‡æ®µå¯ä»¥åŸ·è¡Œ 2 bytesã€‚å¦‚æœæ”¹ç”¨ `mov bl, XX` (0xb3) instruction ä¾†å–ä»£ `jmp`ï¼Œå‰‡å¯ä»¥å„ªåŒ–åˆ° 3 bytes shellcodeã€‚

æ§‹é€ å¥½çš„ filter program æœƒé•·å¾—åƒï¼š
```c
struct sock_filter insns[] = {
    // spraying NOPs
    {.code = BPF_LD + BPF_K, .k = 0xb3909090},
    {.code = BPF_LD + BPF_K, .k = 0xb3909090},
    // [...]

    // kernel shellcode
    {.code = BPF_LD + BPF_K, .k = (0xb3 << 24) + SHELLCODE_1 /* 3 bytes shellcode */},
    {.code = BPF_LD + BPF_K, .k = (0xb3 << 24) + SHELLCODE_2 /* 3 bytes shellcode */},
    // [...]

    // return allow
    {.code = BPF_RET + BPF_K, .k = SECCOMP_RET_ALLOW}
};

struct sock_fprog sock_fprog = {
    .len = sizeof(insns) / sizeof(insns[0]),
    .filter = insns,
};
```

æ¥ä¸‹ä¾†å¯ä»¥åƒä½œè€…ä¸€æ¨£ç”¨ `prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER)` [1] attach program åˆ° processï¼Œæˆ–æ˜¯ [Balsn çš„ writeup](https://balsn.tw/ctf_writeup/20211211-secconctf2021/) ä½¿ç”¨ `setsockopt(SO_ATTACH_FILTER)` [2] ä¾† attach program åˆ° socket fdã€‚

```c
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &sock_fprog); // [1]
setsockopt(fd, SOL_SOCKET, SO_ATTACH_FILTER, &sock_fprog, sizeof(sock_fprog)); // [2]
```

å¾ kernel function `bpf_jit_alloc_exec()` å¯ä»¥çŸ¥é“ BPF çš„ JIT code æœƒåˆ†é…åœ¨ module mapping spaceï¼Œ

```c
void *__weak bpf_jit_alloc_exec(unsigned long size)
{
    return module_alloc(size);
}
```

è€Œåƒè€ƒ [Linux kernel x64 memory layout documentation](https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt) å¯ä»¥çŸ¥é“ module mapping çš„ç¯„åœã€‚

```
# [...]
ffffffffa0000000 |-1536    MB | fffffffffeffffff | 1520 MB | module mapping space
# [...]
```

å› ç‚ºé¡Œç›®æ²’æœ‰ KASLRï¼ŒJIT code æ¯æ¬¡éƒ½æœƒè½åœ¨ `0xffffffffc0000000` çš„ page ä¸Šï¼Œå› æ­¤å¯ä»¥ç²¾æº–çš„æ§åˆ¶ RIP åˆ° JIT code çš„ä¸­é–“ä¾†ææ¬Šã€‚æ­¤æ–¹å¼çš„æˆåŠŸæ©Ÿç‡å–æ±ºæ–¼æ˜¯å¦èƒ½åŸ·è¡Œåˆ°åŸæœ¬ JIT å‡ºä¾†çš„ instruction ä¸­é–“ï¼Œä½†æ˜¯åœ¨æ¯æ¬¡ allocate JIT code memory æ™‚é–‹é ­éƒ½æœƒéš¨æ©ŸåŠ ä¸Šä¸€å°æ®µ offset [3]ï¼Œæ‰€ä»¥é‚„æ˜¯æœ‰ä¸€å®šçš„æ©Ÿç‡æœƒå¤±æ•—ã€‚

```c
struct bpf_binary_header *bpf_jit_binary_pack_alloc(/* ... */)
{
    // [...]
    start = get_random_u32_below(hole) & ~(alignment - 1); // [3]
    // [...]
}
```

å‡è¨­ `0xffffffffc0000690` ç‚º load const instruction çš„é–‹é ­ï¼Œæˆ‘å€‘éœ€è¦æ§åˆ¶ RIP åˆ° 5 bytes çš„ instruction `mov eax, XXX` çš„ä¸­é–“ï¼Œä¹Ÿå°±æ˜¯ offset æ˜¯ 1ã€2ã€3 æˆ– 4 æ™‚æ‰æœƒæˆåŠŸï¼Œå› æ­¤æˆåŠŸæ©Ÿç‡å¤§æ¦‚åªæœ‰ 80% å·¦å³ã€‚

```
pwndbg> x/i 0xffffffffc0000690 + 0
   0xffffffffc0000690:  mov    eax,0xb3909090

pwndbg> x/i 0xffffffffc0000690 + 1
   0xffffffffc0000691:  nop

pwndbg> x/i 0xffffffffc0000690 + 2
   0xffffffffc0000692:  nop

pwndbg> x/i 0xffffffffc0000690 + 3
   0xffffffffc0000693:  nop

pwndbg> x/i 0xffffffffc0000690 + 4
   0xffffffffc0000694:  mov    bl,0xb8
```

é‚£åœ¨ KASLR å•Ÿç”¨çš„æƒ…æ³ä¸‹é‚„èƒ½ä½¿ç”¨é€™å€‹æŠ€å·§å—ï¼Ÿé‡æ–°åˆ†æä¸€ä¸‹ `module_alloc()` çš„å¯¦ä½œï¼Œè©² memory region çš„åˆ†é…å¯¦éš›ä¸Šæ˜¯å¾ `MODULES_VADDR` (0xffffffffc0000000) åŠ ä¸Š `get_module_load_offset()` é–‹å§‹ [4]ï¼š

```c
void *module_alloc(unsigned long size)
{
    // [...]
    p = __vmalloc_node_range(size, MODULE_ALIGN,
                 MODULES_VADDR + get_module_load_offset(), // [4]
                 MODULES_END, gfp_mask, PAGE_KERNEL,
                 VM_FLUSH_RESET_PERMS | VM_DEFER_KMEMLEAK,
                 NUMA_NO_NODE, __builtin_return_address(0));
    // [...]
}
```

`get_module_load_offset()` åœ¨æ²’æœ‰ KASLR çš„æƒ…æ³ä¸‹ä¸æœƒåˆå§‹åŒ–ï¼Œå› æ­¤å€¼ç‚º 0 [5]ï¼Œä½†å¦‚æœå•Ÿç”¨ KASLRï¼Œæœƒéš¨æ©ŸæŒ‘ 1 åˆ° 1024 å€‹ PAGE ä½œç‚º module mapping base address çš„ offset [6]ã€‚

```c
static unsigned long int get_module_load_offset(void)
{
    if (kaslr_enabled()) { // [5]
        // [...]
        if (module_load_offset == 0)
            module_load_offset =
                get_random_u32_inclusive(1, 1024) * PAGE_SIZE; // [6]
        // [...]
    }
    return module_load_offset;
}
```

ä¹Ÿå°±æ˜¯èªª module base æœ€å¤§çš„ offset æœƒæ˜¯ 4 MB (1024 * 0x1000)ã€‚å› æ­¤ç†è«–ä¸Šï¼Œå¦‚æœèƒ½ **spraying è¶…é 4 MB çš„ JIT code**ï¼Œå°‡ RIP æ§åœ¨ overlap çš„ region å°±å¯ä»¥ç¢ºä¿åŸ·è¡Œåˆ°æœ‰ JIT code çš„ addressã€‚

å¯¦å‹™ä¸Šï¼ŒkernelCTF æœ‰è¨±å¤š exploit éƒ½ä½¿ç”¨è©²æŠ€å·§ï¼Œåƒæ˜¯ [CVE-2023-3776](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-3776_lts/exploit/lts-6.1.36)ã€[CVE-2023-4207](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4207_lts_cos/exploit/lts-6.1.36)ã€[CVE-2023-4206](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4206_lts_cos/exploit/lts-6.1.36)ã€[CVE-2023-3609](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-3609_cos_mitigation/exploit/mitigation-6.1)ã€[CVE-2023-4208](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4208_lts_cos_mitigation/exploit/lts-6.1.36) ç­‰ç­‰ã€‚

Fun fact: é€™äº› kernelCTF slot çš„ owner éƒ½æ˜¯ STARLabs çš„ Billyï¼ŒåŒæ™‚ä»–ä¹Ÿæ˜¯ç•¶åˆæƒ³åˆ°é€™å€‹åˆ©ç”¨æŠ€å·§çš„äºº ğŸ˜†

<br>

## 4. Others

é›–ç„¶æœ‰äº›é¡Œç›®ä¸æ˜¯ç›´æ¥æä¾›ä»»æ„ä½ç½®æ§ä¸€å€‹ bit æˆ– byte çš„ primitiveï¼Œä½†æ˜¯ä»ç„¶åœ¨åˆ©ç”¨æ¢ä»¶å¾ˆä¾·é™çš„æƒ…æ³ä¸‹ï¼Œç”¨å¤ é€šç”¨çš„åšæ³•ä¾† exploitï¼Œä¸€æ¨£éå¸¸æœ‰è¶£ã€‚é€™äº›é¡Œç›®çš„åˆ†æéƒ½æœƒç´€éŒ„åœ¨é€™å€‹ sectionã€‚

<br>

### 4.1 Heap-relative 1-byte OOBW - AIS3 EOF CTF Final 2022: oneshot
é¡Œç›®å…è¨±ä½¿ç”¨è€…ç”³è«‹ä¸€å¡ŠæŒ‡å®šå¤§å°çš„ `kmalloc()` chunkï¼Œä¸¦ä¸”é€é race condition å¯ä»¥åšåˆ° heap object 1 byte out-of-bounds writeã€‚æ­¤é¡Œçš„ exploit æŠ€å·§åƒè€ƒ STAR Labs åœ¨ HITCON CMT 2021 ç™¼è¡¨çš„ talk [The Great Escape - A Case Study of VM Escape and EoP Vulnerabilities](https://github.com/star-sg/Presentations/blob/main/HITCON%202021/The%20Great%20Escape%20-%20A%20Case%20Study%20of%20VM%20Escape%20and%20EoP%20Vulnerabilities(HITCON%202021).pdf)ï¼Œå…ˆé–‹å•Ÿ O_RDONLY çš„é«˜æ¬Šé™æª”æ¡ˆå¦‚ "/etc/passwd"ï¼Œä¹‹å¾Œ mmap è©²æª”æ¡ˆä¸¦ spray åªæœ‰ä¸€å€‹ PTE çš„ page mapï¼Œå†é€éé¡Œç›®çµ¦çš„ primitive åˆ†é…ä¸€å¡Šå¤§å°ç‚º 0x1000 çš„ chunkï¼Œä¸¦ OOB write å°‡ index 0 çš„ PTE çš„ R/W bit å¯«æˆ 1ï¼Œé€™æ¨£åŸæœ¬å”¯è®€çš„ "/etc/passwd" å°±è®Šå¾—å¯å¯«ã€‚

<br>

### 4.2 Heap-relative 1-bit Flip - zer0pts CTF 2023: flipper

> åƒè€ƒï¼š https://gist.github.com/leesh3288/5306faa8d0e2deeda81608361eb0b2f2

æä¾› heap object ç›¸å° offset çš„ flip bit primitiveï¼Œä¸€æ¨£å¯ä»¥ flip PTE çš„ R/W bit ä¾†è§£ã€‚ä½œè€…çš„é æœŸè§£æ˜¯é€é spray `struct cred` èˆ‡ io_uring çš„åŠŸèƒ½ä¾†è§£ï¼Œè€Œå…¶ä»–çš„è§£æ³•åŒ…å«ï¼š

1. Flip bit in `file->f_mode` to `FMODE_WRITE` and write RO file - éœ€è¦æ³¨æ„ `vfs_write()` æœƒæª¢æŸ¥ `file->f_mode & FMODE_CAN_WRITE`ï¼Œå› æ­¤è¦ç”¨ `aio_write()` æˆ– `mmap()` ä¾†å¯«
2. Flip a pointer or refcount for UAF - èµ°å¸¸è¦‹çš„ kernel exploit å¥—è·¯
3. Flip a bit in length field - èµ°å¸¸è¦‹çš„ kernel exploit å¥—è·¯

